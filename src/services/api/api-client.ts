/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, {
  AxiosError,
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  CancelToken,
} from 'axios';

export class ProductClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  create(dto: CreateProductDto, cancelToken?: CancelToken | undefined): Promise<ProductDto> {
    let url_ = this.baseUrl + '/api/products';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(dto);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreate(_response);
      });
  }

  protected processCreate(response: AxiosResponse): Promise<ProductDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ProductDto.fromJS(resultData200);
      return Promise.resolve<ProductDto>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ProductDto>(null as any);
  }

  delete(id?: number | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/products?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'DELETE',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDelete(_response);
      });
  }

  protected processDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param search (optional)
   * @param productType (optional)
   * @param offset (optional) Offset of list.
   * @param limit (optional) Number of requested records.
   * @param sortBy (optional) Field name for sorting in DB.
   * @param sortOrder (optional) Sort direction. Ascending or Descending.
   */
  search(
    search?: string | null | undefined,
    productType?: ProductType | null | undefined,
    offset?: number | null | undefined,
    limit?: number | null | undefined,
    sortBy?: string | null | undefined,
    sortOrder?: SortOrder | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<PagedResultOfProductListItemDto> {
    let url_ = this.baseUrl + '/api/products?';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (productType !== undefined && productType !== null)
      url_ += 'ProductType=' + encodeURIComponent('' + productType) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (limit !== undefined && limit !== null)
      url_ += 'Limit=' + encodeURIComponent('' + limit) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (sortOrder === null) throw new Error("The parameter 'sortOrder' cannot be null.");
    else if (sortOrder !== undefined)
      url_ += 'SortOrder=' + encodeURIComponent('' + sortOrder) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processSearch(_response);
      });
  }

  protected processSearch(response: AxiosResponse): Promise<PagedResultOfProductListItemDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagedResultOfProductListItemDto.fromJS(resultData200);
      return Promise.resolve<PagedResultOfProductListItemDto>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<PagedResultOfProductListItemDto>(null as any);
  }

  patch(
    id: number,
    dto: PatchProductDto,
    cancelToken?: CancelToken | undefined
  ): Promise<ProductDto> {
    let url_ = this.baseUrl + '/api/products/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(dto);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'PATCH',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPatch(_response);
      });
  }

  protected processPatch(response: AxiosResponse): Promise<ProductDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ProductDto.fromJS(resultData200);
      return Promise.resolve<ProductDto>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ProductDto>(null as any);
  }

  get(id: number, cancelToken?: CancelToken | undefined): Promise<ProductDto> {
    let url_ = this.baseUrl + '/api/products/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGet(_response);
      });
  }

  protected processGet(response: AxiosResponse): Promise<ProductDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ProductDto.fromJS(resultData200);
      return Promise.resolve<ProductDto>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ProductDto>(null as any);
  }
}
type SearchProductQueryParameters = {
  search?: string | null;
  productType?: ProductType | null;
  offset?: number | null;
  limit?: number | null;
  sortBy?: string | null;
  sortOrder?: SortOrder | null;
};

type GetProductQueryParameters = {
  id: number;
};

export class ProductQuery {
  get baseUrl() {
    return getBaseUrl() ?? '' + '';
  }

  static get Client() {
    return createClient(ProductClient);
  }

  static get Url() {
    return new ProductQuery();
  }

  search(
    search?: string | null | undefined,
    productType?: ProductType | null | undefined,
    offset?: number | null | undefined,
    limit?: number | null | undefined,
    sortBy?: string | null | undefined,
    sortOrder?: SortOrder | undefined
  ): string {
    let url_ = this.baseUrl + '/api/products?';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (productType !== undefined && productType !== null)
      url_ += 'ProductType=' + encodeURIComponent('' + productType) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (limit !== undefined && limit !== null)
      url_ += 'Limit=' + encodeURIComponent('' + limit) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (sortOrder === null) throw new Error("The parameter 'sortOrder' cannot be null.");
    else if (sortOrder !== undefined)
      url_ += 'SortOrder=' + encodeURIComponent('' + sortOrder) + '&';
    url_ = url_.replace(/[?&]$/, '');
    return url_;
  }

  static searchDefaultOptions?: UseQueryOptions<
    PagedResultOfProductListItemDto,
    unknown,
    PagedResultOfProductListItemDto
  > = {};
  public static searchQueryKey(dto: SearchProductQueryParameters): QueryKey;
  public static searchQueryKey(
    search?: string | null | undefined,
    productType?: ProductType | null | undefined,
    offset?: number | null | undefined,
    limit?: number | null | undefined,
    sortBy?: string | null | undefined,
    sortOrder?: SortOrder | undefined
  ): QueryKey;
  public static searchQueryKey(...params: any[]): QueryKey {
    if (params.length === 1 && isParameterObject(params[0])) {
      const { search, productType, offset, limit, sortBy, sortOrder } =
        params[0] as SearchProductQueryParameters;

      return removeUndefinedFromArrayTail([
        'ProductClient',
        'search',
        search as any,
        productType as any,
        offset as any,
        limit as any,
        sortBy as any,
        sortOrder as any,
      ]);
    } else {
      return removeUndefinedFromArrayTail(['ProductClient', 'search', ...params]);
    }
  }

  private static search(context: QueryFunctionContext) {
    return ProductQuery.Client.search(
      context.queryKey[2] as string | null | undefined,
      context.queryKey[3] as ProductType | null | undefined,
      context.queryKey[4] as number | null | undefined,
      context.queryKey[5] as number | null | undefined,
      context.queryKey[6] as string | null | undefined,
      context.queryKey[7] as SortOrder | undefined
    );
  }

  static useSearchQuery<TSelectData = PagedResultOfProductListItemDto, TError = unknown>(
    dto: SearchProductQueryParameters,
    options?: UseQueryOptions<PagedResultOfProductListItemDto, TError, TSelectData>
  ): UseQueryResult<TSelectData, TError>;
  /**
   * @param search (optional)
   * @param productType (optional)
   * @param offset (optional) Offset of list.
   * @param limit (optional) Number of requested records.
   * @param sortBy (optional) Field name for sorting in DB.
   * @param sortOrder (optional) Sort direction. Ascending or Descending.
   */
  static useSearchQuery<TSelectData = PagedResultOfProductListItemDto, TError = unknown>(
    search?: string | null | undefined,
    productType?: ProductType | null | undefined,
    offset?: number | null | undefined,
    limit?: number | null | undefined,
    sortBy?: string | null | undefined,
    sortOrder?: SortOrder | undefined,
    options?: UseQueryOptions<PagedResultOfProductListItemDto, TError, TSelectData>
  ): UseQueryResult<TSelectData, TError>;
  static useSearchQuery<TSelectData = PagedResultOfProductListItemDto, TError = unknown>(
    ...params: any[]
  ): UseQueryResult<TSelectData, TError> {
    let options: UseQueryOptions<PagedResultOfProductListItemDto, TError, TSelectData> | undefined =
      undefined;
    let search: any = undefined;
    let productType: any = undefined;
    let offset: any = undefined;
    let limit: any = undefined;
    let sortBy: any = undefined;
    let sortOrder: any = undefined;

    if (params.length > 0) {
      if (isParameterObject(params[0])) {
        ({ search, productType, offset, limit, sortBy, sortOrder } =
          params[0] as SearchProductQueryParameters);
        options = params[1];
      } else {
        [search, productType, offset, limit, sortBy, sortOrder, options] = params;
      }
    }

    return useQuery<PagedResultOfProductListItemDto, TError, TSelectData>({
      queryFn: ProductQuery.search,
      queryKey: ProductQuery.searchQueryKey(search, productType, offset, limit, sortBy, sortOrder),
      ...(ProductQuery.searchDefaultOptions as unknown as UseQueryOptions<
        PagedResultOfProductListItemDto,
        TError,
        TSelectData
      >),
      ...options,
    });
  }
  /**
   * @param search (optional)
   * @param productType (optional)
   * @param offset (optional) Offset of list.
   * @param limit (optional) Number of requested records.
   * @param sortBy (optional) Field name for sorting in DB.
   * @param sortOrder (optional) Sort direction. Ascending or Descending.
   */
  static setSearchData(
    queryClient: QueryClient,
    updater: (data: PagedResultOfProductListItemDto | undefined) => PagedResultOfProductListItemDto,
    search?: string | null | undefined,
    productType?: ProductType | null | undefined,
    offset?: number | null | undefined,
    limit?: number | null | undefined,
    sortBy?: string | null | undefined,
    sortOrder?: SortOrder | undefined
  ) {
    queryClient.setQueryData(
      ProductQuery.searchQueryKey(search, productType, offset, limit, sortBy, sortOrder),
      updater
    );
  }

  /**
   * @param search (optional)
   * @param productType (optional)
   * @param offset (optional) Offset of list.
   * @param limit (optional) Number of requested records.
   * @param sortBy (optional) Field name for sorting in DB.
   * @param sortOrder (optional) Sort direction. Ascending or Descending.
   */
  static setSearchDataByQueryId(
    queryClient: QueryClient,
    queryKey: QueryKey,
    updater: (data: PagedResultOfProductListItemDto | undefined) => PagedResultOfProductListItemDto
  ) {
    queryClient.setQueryData(queryKey, updater);
  }

  get(id: number): string {
    let url_ = this.baseUrl + '/api/products/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');
    return url_;
  }

  static getDefaultOptions?: UseQueryOptions<ProductDto, unknown, ProductDto> = {};
  public static getQueryKey(id: number): QueryKey;
  public static getQueryKey(...params: any[]): QueryKey {
    if (params.length === 1 && isParameterObject(params[0])) {
      const { id } = params[0] as GetProductQueryParameters;

      return removeUndefinedFromArrayTail(['ProductClient', 'get', id as any]);
    } else {
      return removeUndefinedFromArrayTail(['ProductClient', 'get', ...params]);
    }
  }

  private static get(context: QueryFunctionContext) {
    return ProductQuery.Client.get(context.queryKey[2] as number);
  }

  static useGetQuery<TSelectData = ProductDto, TError = unknown>(
    dto: GetProductQueryParameters,
    options?: UseQueryOptions<ProductDto, TError, TSelectData>
  ): UseQueryResult<TSelectData, TError>;
  static useGetQuery<TSelectData = ProductDto, TError = unknown>(
    id: number,
    options?: UseQueryOptions<ProductDto, TError, TSelectData>
  ): UseQueryResult<TSelectData, TError>;
  static useGetQuery<TSelectData = ProductDto, TError = unknown>(
    ...params: any[]
  ): UseQueryResult<TSelectData, TError> {
    let options: UseQueryOptions<ProductDto, TError, TSelectData> | undefined = undefined;
    let id: any = undefined;

    if (params.length > 0) {
      if (isParameterObject(params[0])) {
        ({ id } = params[0] as GetProductQueryParameters);
        options = params[1];
      } else {
        [id, options] = params;
      }
    }

    return useQuery<ProductDto, TError, TSelectData>({
      queryFn: ProductQuery.get,
      queryKey: ProductQuery.getQueryKey(id),
      ...(ProductQuery.getDefaultOptions as unknown as UseQueryOptions<
        ProductDto,
        TError,
        TSelectData
      >),
      ...options,
    });
  }
  static setGetData(
    queryClient: QueryClient,
    updater: (data: ProductDto | undefined) => ProductDto,
    id: number
  ) {
    queryClient.setQueryData(ProductQuery.getQueryKey(id), updater);
  }

  static setGetDataByQueryId(
    queryClient: QueryClient,
    queryKey: QueryKey,
    updater: (data: ProductDto | undefined) => ProductDto
  ) {
    queryClient.setQueryData(queryKey, updater);
  }
}

export class DbSchemeClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getTableScheme(cancelToken?: CancelToken | undefined): Promise<DbSchemeDto> {
    let url_ = this.baseUrl + '/api/scheme';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetTableScheme(_response);
      });
  }

  protected processGetTableScheme(response: AxiosResponse): Promise<DbSchemeDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = DbSchemeDto.fromJS(resultData200);
      return Promise.resolve<DbSchemeDto>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<DbSchemeDto>(null as any);
  }
}
export class DbSchemeQuery {
  get baseUrl() {
    return getBaseUrl() ?? '' + '';
  }

  static get Client() {
    return createClient(DbSchemeClient);
  }

  static get Url() {
    return new DbSchemeQuery();
  }

  getTableScheme(): string {
    let url_ = this.baseUrl + '/api/scheme';
    url_ = url_.replace(/[?&]$/, '');
    return url_;
  }

  static getTableSchemeDefaultOptions?: UseQueryOptions<DbSchemeDto, unknown, DbSchemeDto> = {};
  public static getTableSchemeQueryKey(): QueryKey;
  public static getTableSchemeQueryKey(...params: any[]): QueryKey {
    return removeUndefinedFromArrayTail(['DbSchemeClient', 'getTableScheme']);
  }

  private static getTableScheme() {
    return DbSchemeQuery.Client.getTableScheme();
  }

  static useGetTableSchemeQuery<TSelectData = DbSchemeDto, TError = unknown>(
    options?: UseQueryOptions<DbSchemeDto, TError, TSelectData>
  ): UseQueryResult<TSelectData, TError>;
  static useGetTableSchemeQuery<TSelectData = DbSchemeDto, TError = unknown>(
    ...params: any[]
  ): UseQueryResult<TSelectData, TError> {
    let options: UseQueryOptions<DbSchemeDto, TError, TSelectData> | undefined = undefined;

    options = params[0] as any;

    return useQuery<DbSchemeDto, TError, TSelectData>({
      queryFn: DbSchemeQuery.getTableScheme,
      queryKey: DbSchemeQuery.getTableSchemeQueryKey(),
      ...(DbSchemeQuery.getTableSchemeDefaultOptions as unknown as UseQueryOptions<
        DbSchemeDto,
        TError,
        TSelectData
      >),
      ...options,
    });
  }
  static setGetTableSchemeData(
    queryClient: QueryClient,
    updater: (data: DbSchemeDto | undefined) => DbSchemeDto
  ) {
    queryClient.setQueryData(DbSchemeQuery.getTableSchemeQueryKey(), updater);
  }

  static setGetTableSchemeDataByQueryId(
    queryClient: QueryClient,
    queryKey: QueryKey,
    updater: (data: DbSchemeDto | undefined) => DbSchemeDto
  ) {
    queryClient.setQueryData(queryKey, updater);
  }
}

export class OpenIdAuthorizationClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  externalCallbackGET(
    remoteError?: string | null | undefined,
    originalQuery?: string | null | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/connect/authorize/callback?';
    if (remoteError !== undefined && remoteError !== null)
      url_ += 'remoteError=' + encodeURIComponent('' + remoteError) + '&';
    if (originalQuery !== undefined && originalQuery !== null)
      url_ += 'originalQuery=' + encodeURIComponent('' + originalQuery) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processExternalCallbackGET(_response);
      });
  }

  protected processExternalCallbackGET(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  externalCallbackPOST(
    remoteError?: string | null | undefined,
    originalQuery?: string | null | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/connect/authorize/callback?';
    if (remoteError !== undefined && remoteError !== null)
      url_ += 'remoteError=' + encodeURIComponent('' + remoteError) + '&';
    if (originalQuery !== undefined && originalQuery !== null)
      url_ += 'originalQuery=' + encodeURIComponent('' + originalQuery) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processExternalCallbackPOST(_response);
      });
  }

  protected processExternalCallbackPOST(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  authorizeGET(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/connect/authorize';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAuthorizeGET(_response);
      });
  }

  protected processAuthorizeGET(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  authorizePOST(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/connect/authorize';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAuthorizePOST(_response);
      });
  }

  protected processAuthorizePOST(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  exchange(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/connect/token';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processExchange(_response);
      });
  }

  protected processExchange(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }
}
type ExternalCallbackGETOpenIdAuthorizationQueryParameters = {
  remoteError?: string | null;
  originalQuery?: string | null;
};

export class OpenIdAuthorizationQuery {
  get baseUrl() {
    return getBaseUrl() ?? '' + '';
  }

  static get Client() {
    return createClient(OpenIdAuthorizationClient);
  }

  static get Url() {
    return new OpenIdAuthorizationQuery();
  }

  externalCallbackGET(
    remoteError?: string | null | undefined,
    originalQuery?: string | null | undefined
  ): string {
    let url_ = this.baseUrl + '/connect/authorize/callback?';
    if (remoteError !== undefined && remoteError !== null)
      url_ += 'remoteError=' + encodeURIComponent('' + remoteError) + '&';
    if (originalQuery !== undefined && originalQuery !== null)
      url_ += 'originalQuery=' + encodeURIComponent('' + originalQuery) + '&';
    url_ = url_.replace(/[?&]$/, '');
    return url_;
  }

  static externalCallbackGETDefaultOptions?: UseQueryOptions<void, unknown, void> = {};
  public static externalCallbackGETQueryKey(
    dto: ExternalCallbackGETOpenIdAuthorizationQueryParameters
  ): QueryKey;
  public static externalCallbackGETQueryKey(
    remoteError?: string | null | undefined,
    originalQuery?: string | null | undefined
  ): QueryKey;
  public static externalCallbackGETQueryKey(...params: any[]): QueryKey {
    if (params.length === 1 && isParameterObject(params[0])) {
      const { remoteError, originalQuery } =
        params[0] as ExternalCallbackGETOpenIdAuthorizationQueryParameters;

      return removeUndefinedFromArrayTail([
        'OpenIdAuthorizationClient',
        'externalCallbackGET',
        remoteError as any,
        originalQuery as any,
      ]);
    } else {
      return removeUndefinedFromArrayTail([
        'OpenIdAuthorizationClient',
        'externalCallbackGET',
        ...params,
      ]);
    }
  }

  private static externalCallbackGET(context: QueryFunctionContext) {
    return OpenIdAuthorizationQuery.Client.externalCallbackGET(
      context.queryKey[2] as string | null | undefined,
      context.queryKey[3] as string | null | undefined
    );
  }

  static useExternalCallbackGETQuery<TSelectData = void, TError = unknown>(
    dto: ExternalCallbackGETOpenIdAuthorizationQueryParameters,
    options?: UseQueryOptions<void, TError, TSelectData>
  ): UseQueryResult<TSelectData, TError>;
  static useExternalCallbackGETQuery<TSelectData = void, TError = unknown>(
    remoteError?: string | null | undefined,
    originalQuery?: string | null | undefined,
    options?: UseQueryOptions<void, TError, TSelectData>
  ): UseQueryResult<TSelectData, TError>;
  static useExternalCallbackGETQuery<TSelectData = void, TError = unknown>(
    ...params: any[]
  ): UseQueryResult<TSelectData, TError> {
    let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
    let remoteError: any = undefined;
    let originalQuery: any = undefined;

    if (params.length > 0) {
      if (isParameterObject(params[0])) {
        ({ remoteError, originalQuery } =
          params[0] as ExternalCallbackGETOpenIdAuthorizationQueryParameters);
        options = params[1];
      } else {
        [remoteError, originalQuery, options] = params;
      }
    }

    return useQuery<void, TError, TSelectData>({
      queryFn: OpenIdAuthorizationQuery.externalCallbackGET,
      queryKey: OpenIdAuthorizationQuery.externalCallbackGETQueryKey(remoteError, originalQuery),
      ...(OpenIdAuthorizationQuery.externalCallbackGETDefaultOptions as unknown as UseQueryOptions<
        void,
        TError,
        TSelectData
      >),
      ...options,
    });
  }
  static setExternalCallbackGETData(
    queryClient: QueryClient,
    updater: (data: void | undefined) => void,
    remoteError?: string | null | undefined,
    originalQuery?: string | null | undefined
  ) {
    queryClient.setQueryData(
      OpenIdAuthorizationQuery.externalCallbackGETQueryKey(remoteError, originalQuery),
      updater
    );
  }

  static setExternalCallbackGETDataByQueryId(
    queryClient: QueryClient,
    queryKey: QueryKey,
    updater: (data: void | undefined) => void
  ) {
    queryClient.setQueryData(queryKey, updater);
  }

  authorizeGET(): string {
    let url_ = this.baseUrl + '/connect/authorize';
    url_ = url_.replace(/[?&]$/, '');
    return url_;
  }

  static authorizeGETDefaultOptions?: UseQueryOptions<void, unknown, void> = {};
  public static authorizeGETQueryKey(): QueryKey;
  public static authorizeGETQueryKey(...params: any[]): QueryKey {
    return removeUndefinedFromArrayTail(['OpenIdAuthorizationClient', 'authorizeGET']);
  }

  private static authorizeGET() {
    return OpenIdAuthorizationQuery.Client.authorizeGET();
  }

  static useAuthorizeGETQuery<TSelectData = void, TError = unknown>(
    options?: UseQueryOptions<void, TError, TSelectData>
  ): UseQueryResult<TSelectData, TError>;
  static useAuthorizeGETQuery<TSelectData = void, TError = unknown>(
    ...params: any[]
  ): UseQueryResult<TSelectData, TError> {
    let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;

    options = params[0] as any;

    return useQuery<void, TError, TSelectData>({
      queryFn: OpenIdAuthorizationQuery.authorizeGET,
      queryKey: OpenIdAuthorizationQuery.authorizeGETQueryKey(),
      ...(OpenIdAuthorizationQuery.authorizeGETDefaultOptions as unknown as UseQueryOptions<
        void,
        TError,
        TSelectData
      >),
      ...options,
    });
  }
  static setAuthorizeGETData(queryClient: QueryClient, updater: (data: void | undefined) => void) {
    queryClient.setQueryData(OpenIdAuthorizationQuery.authorizeGETQueryKey(), updater);
  }

  static setAuthorizeGETDataByQueryId(
    queryClient: QueryClient,
    queryKey: QueryKey,
    updater: (data: void | undefined) => void
  ) {
    queryClient.setQueryData(queryKey, updater);
  }
}

export class SignUrlClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getSignature(cancelToken?: CancelToken | undefined): Promise<string> {
    let url_ = this.baseUrl + '/api/sign-url/signature';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetSignature(_response);
      });
  }

  protected processGetSignature(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<string>(null as any);
  }

  setSignatureCookie(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/sign-url/signature/cookie';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processSetSignatureCookie(_response);
      });
  }

  protected processSetSignatureCookie(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }
}
export class SignUrlQuery {
  get baseUrl() {
    return getBaseUrl() ?? '' + '';
  }

  static get Client() {
    return createClient(SignUrlClient);
  }

  static get Url() {
    return new SignUrlQuery();
  }

  getSignature(): string {
    let url_ = this.baseUrl + '/api/sign-url/signature';
    url_ = url_.replace(/[?&]$/, '');
    return url_;
  }

  static getSignatureDefaultOptions?: UseQueryOptions<string, unknown, string> = {};
  public static getSignatureQueryKey(): QueryKey;
  public static getSignatureQueryKey(...params: any[]): QueryKey {
    return removeUndefinedFromArrayTail(['SignUrlClient', 'getSignature']);
  }

  private static getSignature() {
    return SignUrlQuery.Client.getSignature();
  }

  static useGetSignatureQuery<TSelectData = string, TError = unknown>(
    options?: UseQueryOptions<string, TError, TSelectData>
  ): UseQueryResult<TSelectData, TError>;
  static useGetSignatureQuery<TSelectData = string, TError = unknown>(
    ...params: any[]
  ): UseQueryResult<TSelectData, TError> {
    let options: UseQueryOptions<string, TError, TSelectData> | undefined = undefined;

    options = params[0] as any;

    return useQuery<string, TError, TSelectData>({
      queryFn: SignUrlQuery.getSignature,
      queryKey: SignUrlQuery.getSignatureQueryKey(),
      ...(SignUrlQuery.getSignatureDefaultOptions as unknown as UseQueryOptions<
        string,
        TError,
        TSelectData
      >),
      ...options,
    });
  }
  static setGetSignatureData(
    queryClient: QueryClient,
    updater: (data: string | undefined) => string
  ) {
    queryClient.setQueryData(SignUrlQuery.getSignatureQueryKey(), updater);
  }

  static setGetSignatureDataByQueryId(
    queryClient: QueryClient,
    queryKey: QueryKey,
    updater: (data: string | undefined) => string
  ) {
    queryClient.setQueryData(queryKey, updater);
  }

  setSignatureCookie(): string {
    let url_ = this.baseUrl + '/api/sign-url/signature/cookie';
    url_ = url_.replace(/[?&]$/, '');
    return url_;
  }

  static setSignatureCookieDefaultOptions?: UseQueryOptions<void, unknown, void> = {};
  public static setSignatureCookieQueryKey(): QueryKey;
  public static setSignatureCookieQueryKey(...params: any[]): QueryKey {
    return removeUndefinedFromArrayTail(['SignUrlClient', 'setSignatureCookie']);
  }

  private static setSignatureCookie() {
    return SignUrlQuery.Client.setSignatureCookie();
  }

  static useSetSignatureCookieQuery<TSelectData = void, TError = unknown>(
    options?: UseQueryOptions<void, TError, TSelectData>
  ): UseQueryResult<TSelectData, TError>;
  static useSetSignatureCookieQuery<TSelectData = void, TError = unknown>(
    ...params: any[]
  ): UseQueryResult<TSelectData, TError> {
    let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;

    options = params[0] as any;

    return useQuery<void, TError, TSelectData>({
      queryFn: SignUrlQuery.setSignatureCookie,
      queryKey: SignUrlQuery.setSignatureCookieQueryKey(),
      ...(SignUrlQuery.setSignatureCookieDefaultOptions as unknown as UseQueryOptions<
        void,
        TError,
        TSelectData
      >),
      ...options,
    });
  }
  static setSetSignatureCookieData(
    queryClient: QueryClient,
    updater: (data: void | undefined) => void
  ) {
    queryClient.setQueryData(SignUrlQuery.setSignatureCookieQueryKey(), updater);
  }

  static setSetSignatureCookieDataByQueryId(
    queryClient: QueryClient,
    queryKey: QueryKey,
    updater: (data: void | undefined) => void
  ) {
    queryClient.setQueryData(queryKey, updater);
  }
}

export class TestDataClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * Demonstrates an error response.
   */
  throwError(cancelToken?: CancelToken | undefined): Promise<string> {
    let url_ = this.baseUrl + '/error-test';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processThrowError(_response);
      });
  }

  protected processThrowError(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * Sends a dummy email
   */
  sendEmail(cancelToken?: CancelToken | undefined): Promise<string> {
    let url_ = this.baseUrl + '/send-email';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processSendEmail(_response);
      });
  }

  protected processSendEmail(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * Tests RequiredOrUndefined attribute
   */
  patch(dto: TestPatchDto, cancelToken?: CancelToken | undefined): Promise<string> {
    let url_ = this.baseUrl + '/patch';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(dto);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPatch(_response);
      });
  }

  protected processPatch(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * Try this in browser with language set to DE
   * @param a (optional)
   */
  formData(a?: number | undefined, cancelToken?: CancelToken | undefined): Promise<string> {
    let url_ = this.baseUrl + '/formdata';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (a === null || a === undefined) throw new Error("The parameter 'a' cannot be null.");
    else content_.append('A', a.toString());

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processFormData(_response);
      });
  }

  protected processFormData(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<string>(null as any);
  }
}
export class TestDataQuery {
  get baseUrl() {
    return getBaseUrl() ?? '' + '';
  }

  static get Client() {
    return createClient(TestDataClient);
  }

  static get Url() {
    return new TestDataQuery();
  }

  throwError(): string {
    let url_ = this.baseUrl + '/error-test';
    url_ = url_.replace(/[?&]$/, '');
    return url_;
  }

  static throwErrorDefaultOptions?: UseQueryOptions<string, unknown, string> = {};
  public static throwErrorQueryKey(): QueryKey;
  public static throwErrorQueryKey(...params: any[]): QueryKey {
    return removeUndefinedFromArrayTail(['TestDataClient', 'throwError']);
  }

  private static throwError() {
    return TestDataQuery.Client.throwError();
  }

  /**
   * Demonstrates an error response.
   */
  static useThrowErrorQuery<TSelectData = string, TError = unknown>(
    options?: UseQueryOptions<string, TError, TSelectData>
  ): UseQueryResult<TSelectData, TError>;
  static useThrowErrorQuery<TSelectData = string, TError = unknown>(
    ...params: any[]
  ): UseQueryResult<TSelectData, TError> {
    let options: UseQueryOptions<string, TError, TSelectData> | undefined = undefined;

    options = params[0] as any;

    return useQuery<string, TError, TSelectData>({
      queryFn: TestDataQuery.throwError,
      queryKey: TestDataQuery.throwErrorQueryKey(),
      ...(TestDataQuery.throwErrorDefaultOptions as unknown as UseQueryOptions<
        string,
        TError,
        TSelectData
      >),
      ...options,
    });
  }
  /**
   * Demonstrates an error response.
   */
  static setThrowErrorData(
    queryClient: QueryClient,
    updater: (data: string | undefined) => string
  ) {
    queryClient.setQueryData(TestDataQuery.throwErrorQueryKey(), updater);
  }

  /**
   * Demonstrates an error response.
   */
  static setThrowErrorDataByQueryId(
    queryClient: QueryClient,
    queryKey: QueryKey,
    updater: (data: string | undefined) => string
  ) {
    queryClient.setQueryData(queryKey, updater);
  }
}

export class VersionClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * Gets the version of the service.
   * @return A string representing the version.
   */
  version(cancelToken?: CancelToken | undefined): Promise<string> {
    let url_ = this.baseUrl + '/api';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processVersion(_response);
      });
  }

  protected processVersion(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<string>(null as any);
  }
}
export class VersionQuery {
  get baseUrl() {
    return getBaseUrl() ?? '' + '';
  }

  static get Client() {
    return createClient(VersionClient);
  }

  static get Url() {
    return new VersionQuery();
  }

  version(): string {
    let url_ = this.baseUrl + '/api';
    url_ = url_.replace(/[?&]$/, '');
    return url_;
  }

  static versionDefaultOptions?: UseQueryOptions<string, unknown, string> = {};
  public static versionQueryKey(): QueryKey;
  public static versionQueryKey(...params: any[]): QueryKey {
    return removeUndefinedFromArrayTail(['VersionClient', 'version']);
  }

  private static version() {
    return VersionQuery.Client.version();
  }

  /**
   * Gets the version of the service.
   * @return A string representing the version.
   */
  static useVersionQuery<TSelectData = string, TError = unknown>(
    options?: UseQueryOptions<string, TError, TSelectData>
  ): UseQueryResult<TSelectData, TError>;
  static useVersionQuery<TSelectData = string, TError = unknown>(
    ...params: any[]
  ): UseQueryResult<TSelectData, TError> {
    let options: UseQueryOptions<string, TError, TSelectData> | undefined = undefined;

    options = params[0] as any;

    return useQuery<string, TError, TSelectData>({
      queryFn: VersionQuery.version,
      queryKey: VersionQuery.versionQueryKey(),
      ...(VersionQuery.versionDefaultOptions as unknown as UseQueryOptions<
        string,
        TError,
        TSelectData
      >),
      ...options,
    });
  }
  /**
   * Gets the version of the service.
   * @return A string representing the version.
   */
  static setVersionData(queryClient: QueryClient, updater: (data: string | undefined) => string) {
    queryClient.setQueryData(VersionQuery.versionQueryKey(), updater);
  }

  /**
   * Gets the version of the service.
   * @return A string representing the version.
   */
  static setVersionDataByQueryId(
    queryClient: QueryClient,
    queryKey: QueryKey,
    updater: (data: string | undefined) => string
  ) {
    queryClient.setQueryData(queryKey, updater);
  }
}

export class ProblemDetails implements IProblemDetails {
  type?: string | null;
  title?: string | null;
  status?: number | null;
  detail?: string | null;
  instance?: string | null;
  extensions?: { [key: string]: any };

  constructor(data?: IProblemDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data['type'];
      this.title = _data['title'];
      this.status = _data['status'];
      this.detail = _data['detail'];
      this.instance = _data['instance'];
      if (_data['extensions']) {
        this.extensions = {} as any;
        for (let key in _data['extensions']) {
          if (_data['extensions'].hasOwnProperty(key))
            (<any>this.extensions)![key] = _data['extensions'][key];
        }
      }
    }
  }

  static fromJS(data: any): ProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new ProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['type'] = this.type;
    data['title'] = this.title;
    data['status'] = this.status;
    data['detail'] = this.detail;
    data['instance'] = this.instance;
    if (this.extensions) {
      data['extensions'] = {};
      for (let key in this.extensions) {
        if (this.extensions.hasOwnProperty(key))
          (<any>data['extensions'])[key] = this.extensions[key];
      }
    }
    return data;
  }
}

export interface IProblemDetails {
  type?: string | null;
  title?: string | null;
  status?: number | null;
  detail?: string | null;
  instance?: string | null;
  extensions?: { [key: string]: any };
}

export class HttpValidationProblemDetails
  extends ProblemDetails
  implements IHttpValidationProblemDetails
{
  errors?: { [key: string]: string[] };

  constructor(data?: IHttpValidationProblemDetails) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      if (_data['errors']) {
        this.errors = {} as any;
        for (let key in _data['errors']) {
          if (_data['errors'].hasOwnProperty(key))
            (<any>this.errors)![key] =
              _data['errors'][key] !== undefined ? _data['errors'][key] : [];
        }
      }
    }
  }

  static fromJS(data: any): HttpValidationProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new HttpValidationProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.errors) {
      data['errors'] = {};
      for (let key in this.errors) {
        if (this.errors.hasOwnProperty(key)) (<any>data['errors'])[key] = this.errors[key];
      }
    }
    super.toJSON(data);
    return data;
  }
}

export interface IHttpValidationProblemDetails extends IProblemDetails {
  errors?: { [key: string]: string[] };
}

export class ValidationProblemDetails
  extends HttpValidationProblemDetails
  implements IValidationProblemDetails
{
  constructor(data?: IValidationProblemDetails) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      if (_data['errors']) {
        this.errors = {} as any;
        for (let key in _data['errors']) {
          if (_data['errors'].hasOwnProperty(key))
            (<any>this.errors)![key] =
              _data['errors'][key] !== undefined ? _data['errors'][key] : [];
        }
      }
    }
  }

  static fromJS(data: any): ValidationProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new ValidationProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.errors) {
      data['errors'] = {};
      for (let key in this.errors) {
        if (this.errors.hasOwnProperty(key)) (<any>data['errors'])[key] = this.errors[key];
      }
    }
    super.toJSON(data);
    return data;
  }
}

export interface IValidationProblemDetails extends IHttpValidationProblemDetails {
  errors?: { [key: string]: string[] };
}

export class ProductDto implements IProductDto {
  id!: number;
  title!: string;
  productType!: ProductType;
  lastStockUpdatedAt!: Date;

  constructor(data?: IProductDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
      this.productType = _data['productType'];
      this.lastStockUpdatedAt = _data['lastStockUpdatedAt']
        ? parseDateOnly(_data['lastStockUpdatedAt'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): ProductDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    data['productType'] = this.productType;
    data['lastStockUpdatedAt'] = this.lastStockUpdatedAt
      ? formatDate(this.lastStockUpdatedAt)
      : <any>undefined;
    return data;
  }
}

export interface IProductDto {
  id: number;
  title: string;
  productType: ProductType;
  lastStockUpdatedAt: Date;
}

export enum ProductType {
  Undefined = 'Undefined',
  Auto = 'Auto',
  Electronic = 'Electronic',
  Other = 'Other',
}

export class CreateProductDto implements ICreateProductDto {
  title!: string;
  productType!: ProductType;
  lastStockUpdatedAt!: Date;

  constructor(data?: ICreateProductDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.productType = _data['productType'];
      this.lastStockUpdatedAt = _data['lastStockUpdatedAt']
        ? parseDateOnly(_data['lastStockUpdatedAt'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): CreateProductDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['productType'] = this.productType;
    data['lastStockUpdatedAt'] = this.lastStockUpdatedAt
      ? formatDate(this.lastStockUpdatedAt)
      : <any>undefined;
    return data;
  }
}

export interface ICreateProductDto {
  title: string;
  productType: ProductType;
  lastStockUpdatedAt: Date;
}

export class PatchProductDto implements IPatchProductDto {
  title?: string;
  productType?: ProductType;
  lastStockUpdatedAt?: Date;

  constructor(data?: IPatchProductDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.productType = _data['productType'];
      this.lastStockUpdatedAt = _data['lastStockUpdatedAt']
        ? parseDateOnly(_data['lastStockUpdatedAt'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): PatchProductDto {
    data = typeof data === 'object' ? data : {};
    let result = new PatchProductDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['productType'] = this.productType;
    data['lastStockUpdatedAt'] = this.lastStockUpdatedAt
      ? formatDate(this.lastStockUpdatedAt)
      : <any>undefined;
    return data;
  }
}

export interface IPatchProductDto {
  title?: string;
  productType?: ProductType;
  lastStockUpdatedAt?: Date;
}

export class PagedResultOfProductListItemDto implements IPagedResultOfProductListItemDto {
  data!: ProductListItemDto[];
  totalCount!: number;

  constructor(data?: IPagedResultOfProductListItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.data = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(ProductListItemDto.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): PagedResultOfProductListItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultOfProductListItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IPagedResultOfProductListItemDto {
  data: ProductListItemDto[];
  totalCount: number;
}

export class ProductListItemDto implements IProductListItemDto {
  id!: number;
  title!: string;
  productType!: ProductType;
  lastStockUpdatedAt!: Date;

  constructor(data?: IProductListItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
      this.productType = _data['productType'];
      this.lastStockUpdatedAt = _data['lastStockUpdatedAt']
        ? parseDateOnly(_data['lastStockUpdatedAt'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): ProductListItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductListItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    data['productType'] = this.productType;
    data['lastStockUpdatedAt'] = this.lastStockUpdatedAt
      ? formatDate(this.lastStockUpdatedAt)
      : <any>undefined;
    return data;
  }
}

export interface IProductListItemDto {
  id: number;
  title: string;
  productType: ProductType;
  lastStockUpdatedAt: Date;
}

export enum SortOrder {
  Asc = 'Asc',
  Desc = 'Desc',
}

export class DbSchemeDto implements IDbSchemeDto {
  tables!: { [key: string]: TableSchemeDto };
  schemas!: { [key: string]: SchemeDto };

  constructor(data?: IDbSchemeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.tables = {};
      this.schemas = {};
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['tables']) {
        this.tables = {} as any;
        for (let key in _data['tables']) {
          if (_data['tables'].hasOwnProperty(key))
            (<any>this.tables)![key] = _data['tables'][key]
              ? TableSchemeDto.fromJS(_data['tables'][key])
              : new TableSchemeDto();
        }
      }
      if (_data['schemas']) {
        this.schemas = {} as any;
        for (let key in _data['schemas']) {
          if (_data['schemas'].hasOwnProperty(key))
            (<any>this.schemas)![key] = _data['schemas'][key]
              ? SchemeDto.fromJS(_data['schemas'][key])
              : new SchemeDto();
        }
      }
    }
  }

  static fromJS(data: any): DbSchemeDto {
    data = typeof data === 'object' ? data : {};
    let result = new DbSchemeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.tables) {
      data['tables'] = {};
      for (let key in this.tables) {
        if (this.tables.hasOwnProperty(key))
          (<any>data['tables'])[key] = this.tables[key]
            ? this.tables[key].toJSON()
            : <any>undefined;
      }
    }
    if (this.schemas) {
      data['schemas'] = {};
      for (let key in this.schemas) {
        if (this.schemas.hasOwnProperty(key))
          (<any>data['schemas'])[key] = this.schemas[key]
            ? this.schemas[key].toJSON()
            : <any>undefined;
      }
    }
    return data;
  }
}

export interface IDbSchemeDto {
  tables: { [key: string]: TableSchemeDto };
  schemas: { [key: string]: SchemeDto };
}

export class TableSchemeDto implements ITableSchemeDto {
  name!: string;
  attributes!: { [key: string]: AttributeDto };
  primaryKeys!: string[];
  connections?: { [key: string]: ConnectionSchemeDto };

  constructor(data?: ITableSchemeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.attributes = {};
      this.primaryKeys = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      if (_data['attributes']) {
        this.attributes = {} as any;
        for (let key in _data['attributes']) {
          if (_data['attributes'].hasOwnProperty(key))
            (<any>this.attributes)![key] = _data['attributes'][key]
              ? AttributeDto.fromJS(_data['attributes'][key])
              : new AttributeDto();
        }
      }
      if (Array.isArray(_data['primaryKeys'])) {
        this.primaryKeys = [] as any;
        for (let item of _data['primaryKeys']) this.primaryKeys!.push(item);
      }
      if (_data['connections']) {
        this.connections = {} as any;
        for (let key in _data['connections']) {
          if (_data['connections'].hasOwnProperty(key))
            (<any>this.connections)![key] = _data['connections'][key]
              ? ConnectionSchemeDto.fromJS(_data['connections'][key])
              : new ConnectionSchemeDto();
        }
      }
    }
  }

  static fromJS(data: any): TableSchemeDto {
    data = typeof data === 'object' ? data : {};
    let result = new TableSchemeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    if (this.attributes) {
      data['attributes'] = {};
      for (let key in this.attributes) {
        if (this.attributes.hasOwnProperty(key))
          (<any>data['attributes'])[key] = this.attributes[key]
            ? this.attributes[key].toJSON()
            : <any>undefined;
      }
    }
    if (Array.isArray(this.primaryKeys)) {
      data['primaryKeys'] = [];
      for (let item of this.primaryKeys) data['primaryKeys'].push(item);
    }
    if (this.connections) {
      data['connections'] = {};
      for (let key in this.connections) {
        if (this.connections.hasOwnProperty(key))
          (<any>data['connections'])[key] = this.connections[key]
            ? this.connections[key].toJSON()
            : <any>undefined;
      }
    }
    return data;
  }
}

export interface ITableSchemeDto {
  name: string;
  attributes: { [key: string]: AttributeDto };
  primaryKeys: string[];
  connections?: { [key: string]: ConnectionSchemeDto };
}

export class AttributeDto implements IAttributeDto {
  name!: string;
  scheme!: AttributeSchemeDto;
  isUnique!: boolean;
  isNullable!: boolean;
  isPrimary!: boolean;
  isForeignKey!: boolean;

  constructor(data?: IAttributeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.scheme = new AttributeSchemeDto();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.scheme = _data['scheme']
        ? AttributeSchemeDto.fromJS(_data['scheme'])
        : new AttributeSchemeDto();
      this.isUnique = _data['isUnique'];
      this.isNullable = _data['isNullable'];
      this.isPrimary = _data['isPrimary'];
      this.isForeignKey = _data['isForeignKey'];
    }
  }

  static fromJS(data: any): AttributeDto {
    data = typeof data === 'object' ? data : {};
    let result = new AttributeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['scheme'] = this.scheme ? this.scheme.toJSON() : <any>undefined;
    data['isUnique'] = this.isUnique;
    data['isNullable'] = this.isNullable;
    data['isPrimary'] = this.isPrimary;
    data['isForeignKey'] = this.isForeignKey;
    return data;
  }
}

export interface IAttributeDto {
  name: string;
  scheme: AttributeSchemeDto;
  isUnique: boolean;
  isNullable: boolean;
  isPrimary: boolean;
  isForeignKey: boolean;
}

export class AttributeSchemeDto implements IAttributeSchemeDto {
  type!: RealmDataType | null;
  format!: DataFormat | null;
  ref?: string | null;

  constructor(data?: IAttributeSchemeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data['type'];
      this.format = _data['format'];
      this.ref = _data['ref'];
    }
  }

  static fromJS(data: any): AttributeSchemeDto {
    data = typeof data === 'object' ? data : {};
    let result = new AttributeSchemeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['type'] = this.type;
    data['format'] = this.format;
    data['ref'] = this.ref;
    return data;
  }
}

export interface IAttributeSchemeDto {
  type: RealmDataType | null;
  format: DataFormat | null;
  ref?: string | null;
}

export enum RealmDataType {
  Int = 'Int',
  Bool = 'Bool',
  Double = 'Double',
  String = 'String',
  Data = 'Data',
  ObjectId = 'ObjectId',
  Date = 'Date',
}

export enum DataFormat {
  Date = 'Date',
  Time = 'Time',
  DateTime = 'DateTime',
  Json = 'Json',
}

export class ConnectionSchemeDto implements IConnectionSchemeDto {
  tableName!: string;
  ownAttributeNames?: string[];
  externalAttributeNames?: string[];
  isIncomingReference!: boolean;

  constructor(data?: IConnectionSchemeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tableName = _data['tableName'];
      if (Array.isArray(_data['ownAttributeNames'])) {
        this.ownAttributeNames = [] as any;
        for (let item of _data['ownAttributeNames']) this.ownAttributeNames!.push(item);
      }
      if (Array.isArray(_data['externalAttributeNames'])) {
        this.externalAttributeNames = [] as any;
        for (let item of _data['externalAttributeNames']) this.externalAttributeNames!.push(item);
      }
      this.isIncomingReference = _data['isIncomingReference'];
    }
  }

  static fromJS(data: any): ConnectionSchemeDto {
    data = typeof data === 'object' ? data : {};
    let result = new ConnectionSchemeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tableName'] = this.tableName;
    if (Array.isArray(this.ownAttributeNames)) {
      data['ownAttributeNames'] = [];
      for (let item of this.ownAttributeNames) data['ownAttributeNames'].push(item);
    }
    if (Array.isArray(this.externalAttributeNames)) {
      data['externalAttributeNames'] = [];
      for (let item of this.externalAttributeNames) data['externalAttributeNames'].push(item);
    }
    data['isIncomingReference'] = this.isIncomingReference;
    return data;
  }
}

export interface IConnectionSchemeDto {
  tableName: string;
  ownAttributeNames?: string[];
  externalAttributeNames?: string[];
  isIncomingReference: boolean;
}

export class SchemeDto implements ISchemeDto {
  name!: string;
  areValuesConfigured!: boolean | null;
  enum?: { [key: string]: number } | null;

  constructor(data?: ISchemeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.areValuesConfigured = _data['areValuesConfigured'];
      if (_data['enum']) {
        this.enum = {} as any;
        for (let key in _data['enum']) {
          if (_data['enum'].hasOwnProperty(key)) (<any>this.enum)![key] = _data['enum'][key];
        }
      }
    }
  }

  static fromJS(data: any): SchemeDto {
    data = typeof data === 'object' ? data : {};
    let result = new SchemeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['areValuesConfigured'] = this.areValuesConfigured;
    if (this.enum) {
      data['enum'] = {};
      for (let key in this.enum) {
        if (this.enum.hasOwnProperty(key)) (<any>data['enum'])[key] = this.enum[key];
      }
    }
    return data;
  }
}

export interface ISchemeDto {
  name: string;
  areValuesConfigured: boolean | null;
  enum?: { [key: string]: number } | null;
}

export class TestPatchDto implements ITestPatchDto {
  value!: string;

  constructor(data?: ITestPatchDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): TestPatchDto {
    data = typeof data === 'object' ? data : {};
    let result = new TestPatchDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value;
    return data;
  }
}

export interface ITestPatchDto {
  value: string;
}

function formatDate(d: Date) {
  return (
    d.getFullYear() +
    '-' +
    (d.getMonth() < 9 ? '0' + (d.getMonth() + 1) : d.getMonth() + 1) +
    '-' +
    (d.getDate() < 10 ? '0' + d.getDate() : d.getDate())
  );
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
  return obj && obj.isAxiosError === true;
}

import {
  useQuery,
  UseQueryResult,
  QueryFunctionContext,
  UseQueryOptions,
  QueryClient,
  QueryKey,
} from 'react-query';

function removeUndefinedFromArrayTail<T>(arr: T[]): T[] {
  let lastDefinedValueIndex = arr.length - 1;
  while (lastDefinedValueIndex >= 0) {
    if (arr[lastDefinedValueIndex] === undefined) {
      lastDefinedValueIndex--;
    } else {
      break;
    }
  }
  return lastDefinedValueIndex === arr.length - 1 ? arr : arr.slice(0, lastDefinedValueIndex + 1);
}

/*
  Determines if first parameter of useSomethingQuery is an object with query parameters, or it's a regular parameter
  Returns true if parameter is Object
  Returns false if parameter is number/string/boolean/Date or Array
*/
function isParameterObject(param: unknown) {
  if (param === null || param === undefined) return false;
  if (param instanceof Array) return false;
  const isObject = typeof param === 'object';
  if (!isObject) return false;
  if (param instanceof Date) return false;
  return true;
}

type ClientFactoryFunction = <T>(type: new (...params: any[]) => T) => T;
let _clientFactoryFunction: ClientFactoryFunction = <T>(type: new (...params: any[]) => T) => {
  const params = [_baseUrl, _axiosFactory()];
  return new type(...params);
};
/*
  Overrides default Client factory function
*/
export function setClientFactory(value: ClientFactoryFunction) {
  _clientFactoryFunction = value;
}

/*
  Returns current Client factory function
*/
export function getClientFactory() {
  return _clientFactoryFunction;
}

/*
  Function that will be called from `useQuery...` methods to get a client of certain type
*/
function createClient<T>(type: new () => T) {
  return _clientFactoryFunction(type);
}

let _baseUrl = '';
/*
  Returns the base URL for http requests
*/
export function getBaseUrl(): string {
  return _baseUrl;
}

/*
  Sets the base URL for http requests
*/
export function setBaseUrl(baseUrl: string) {
  _baseUrl = baseUrl;
}

let _axiosFactory: () => AxiosInstance | undefined = () => undefined;
/*
  Returns currently used factory for Axios instances
*/
export function getAxiosFactory() {
  return _axiosFactory;
}
/*
  Sets the factory for Axios instances
*/
export function setAxiosFactory(factory: () => AxiosInstance) {
  _axiosFactory = factory;
}

function parseDateOnly(s: string) {
  const date = new Date(s);
  return new Date(date.getTime() + date.getTimezoneOffset() * 60000);
}
